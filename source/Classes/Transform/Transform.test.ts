import { Transform } from "./Transform"
import * as mat4 from "glMatrix/mat4";
import * as vec3 from "glMatrix/vec3";
import * as quat from "glMatrix/quat";

describe('Transform', () => {

    it('has a standard identity matrix when initialized', () => {
        let transform = new Transform();
        expect(transform.getLocalMatrix()).toEqual(mat4.create());
    })

    it('can be overloaded to take initial params', () => {
        const pos = vec3.fromValues(20, 10, 1);
        const scale = vec3.fromValues(10.5, 5.5, 0.5);
        const rot = quat.create();
        const transform = new Transform(rot, pos, scale);
        let matrix = transform.getLocalMatrix();

        // validate the data in the matrix is what we expect.
        let resultRot = quat.create();
        let resultPos = vec3.create();
        let resultSca = vec3.create();

        expect(mat4.getRotation(resultRot, matrix)).toEqual(quat.fromValues(0, 0, 0, 1));
        expect(mat4.getScaling(resultSca, matrix)).toEqual(vec3.fromValues(10.5, 5.5, 0.5));
        expect(mat4.getTranslation(resultPos, matrix)).toEqual(vec3.fromValues(20, 10, 1));
    });

    it('individual getters report correct values', () => {
        const pos = vec3.fromValues(20, 10, 1);
        const scale = vec3.fromValues(10.5, 5.5, 0.5);
        const rot = quat.create();
        const transform = new Transform(rot, pos, scale);

        expect(transform.getTranslation()).toEqual(vec3.fromValues(20, 10, 1));
        expect(transform.getScaling()).toEqual(vec3.fromValues(10.5, 5.5, 0.5));
        expect(transform.getRotation()).toEqual(quat.fromValues(0,0,0,1));
    });

    it('has a setter for position that updates local matrix', () => {
        const transform = new Transform();
        const pos = vec3.fromValues(20, 10, -1);
        transform.setTranslation(pos);
        const matrix = transform.getLocalMatrix();

        expect(mat4.getTranslation(vec3.create(), matrix)).toEqual(pos);
    });

    it('has a setter for scale that updates local matrix', () => {
        const transform = new Transform();
        const scale = vec3.fromValues(10.5, 5.5, 0.5);
        transform.setScaling(scale);
        const matrix = transform.getLocalMatrix();

        expect(mat4.getScaling(vec3.create(), matrix)).toEqual(scale);
    });

    it('has a setter for rotation that updates local matrix', () => {
        const transform = new Transform();
        // 90 degrees clockwise on the z axis, taken from https://www.andre-gaschler.com/rotationconverter/
        const rotation = quat.fromValues(0, 0, 0.7071068, 0.7071068);

        transform.setRotation(rotation);
        const matrix = transform.getLocalMatrix();

        expect(mat4.getRotation(quat.create(), matrix)).toBeEqualish(rotation);
    });

    it('generates the correct worldMatrix', () => {
        const worldPos = vec3.fromValues(200, 100, 10);
        const worldScale = vec3.fromValues(2, 2, 2);
        const worldRotation = quat.fromValues(0, 0, 0.7071068, 0.7071068);
        const parentWorldMatrix = mat4.fromRotationTranslationScale(mat4.create(), worldRotation, worldPos, worldScale);

        console.log(mat4.str(parentWorldMatrix));

        const pos = vec3.fromValues(20, 10, 1);
        const scale = vec3.fromValues(0.5, 0.5, 0.5);
        const rotation = quat.fromValues(0, 0, -0.7071068, 0.7071068);
        const transform = new Transform(rotation, pos, scale);
  
        const worldMatrix = transform.updateWorldMatrix(parentWorldMatrix);

        const testLocal = mat4.fromRotationTranslationScale(mat4.create(), rotation, pos, scale);
        console.log(mat4.str(testLocal));
        /*
            Okay I validated this numbers against a Known Good
            implimentation: Three.js. The worldMatrix generated
            by updateWorldMatrix should (just about) match that 
            generated by Three's worldMatrix for the 'c' object here.

            var three = require("three")
            var o = new three.Object3D();
            o.rotation.set(0,0,1.5707963)
            o.position.set(200, 100, 10);
            o.scale.set(2, 2, 2);
            o.updateMatrix();
            var c = new three.Object3D();
            c.position.set(20, 10, 1);
            c.rotation.set(0,0,-1.5707963)
            c.scale.set(0.5, 0.5, 0.5);
            c.updateMatrix();
            o.add(c);
            o.updateWorldMatrix(false, true);
            console.log(c.matrixWorld);
        */
       expect(transform.updateWorldMatrix(parentWorldMatrix)).toBeEqualish(mat4.fromValues(
            1,0,0,0,
            0,1,0,0,
            0,0,1,0,
            179.999999,140,12,1
        ));
               
    })
})